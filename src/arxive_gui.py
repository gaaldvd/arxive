"""
arXive: A simple CLI/GUI frontend for rsync.

This file contains the code for the GUI mode of arXive.

Check the documentation for details: https://arxive.readthedocs.io

    Copyright (C) 2025 David Gaal (gaaldvd@proton.me)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import sys

from arxive_common import *
from arxive_gui_dialogs import *

from PySide6.QtWidgets import (QApplication, QMainWindow, QWidget, QSizePolicy,
                               QListWidgetItem)
from PySide6.QtCore import Slot, Qt
from PySide6.QtGui import QAction, QIcon, QTextCursor, QColor, QTextCharFormat
from ui.MainWindow import Ui_MainWindow


class OutputRedirector:
    """Handles the redirection of the standard output
    to the :ref:`MainWindow.consoleOutput <mainwindow-class>` widget.

    This class is based on a template and has little to do with
    the application logic. Basically it redirects every `print` command
    of the :ref:`Session.log <log>` method to a `QPlainTextEdit` widget.
    It also colorizes the output based on the nature of the message
    (errors, warnings and successful tasks).
    """

    def __init__(self, plain_text_edit):
        self.plain_text_edit = plain_text_edit

    def write(self, text):
        if text.strip():  # Avoid empty lines
            # Determine color based on content
            if "error" in text.lower():
                color = QColor("red")
            elif "warning" in text.lower():
                color = QColor("orange")
            elif any(keyword in text.lower() for keyword in
                     ["ready", "finished", "saved"]):
                color = QColor("green")
            else:
                color = QColor("black")

            # Append text with the determined color
            self.append_colored_text(text.strip(), color)

    def flush(self):
        pass  # Required for compatibility with `sys.stdout`

    def append_colored_text(self, text, color):
        # Move cursor to the end
        cursor = self.plain_text_edit.textCursor()
        cursor.movePosition(QTextCursor.End)

        # Set text format
        text_format = QTextCharFormat()
        text_format.setForeground(color)

        # Insert text with the format
        cursor.insertText(text + "\n", text_format)

        # Ensure the cursor remains at the end
        self.plain_text_edit.setTextCursor(cursor)


class MainWindow(QMainWindow, Ui_MainWindow):
    """Handles the main window of the application.

    The class inherits from `Pyside6.QtWidgets.QMainWindow`
    and `src.ui.MainWindow.Ui_MainWindow`.

    The GUI was made with QtDesigner. `Ui_MainWindow` is generated by
    pyside6-uic from the QtDesigner .ui file and can be found in
    `/ui/MainWindow.py <https://github.com/gaaldvd/arxive/blob/main/src/ui/MainWindow.py>`_
    in the repository.

    :ivar Session session: Handles arXive session.
    :ivar Config config: Holds configurations.

    Toolbar actions:
        defaults_action(): Sets the default source, destination and options.

        update_action(): Updates the Git repository and the Python environment.

        config_action(): Opens the configuration dialog.

        about_action(): Opens the about window.

        exit_action(): Closes the application.

    Methods (slots):
        config_updated(): Reloads configurations.

        list_deletions(): Lists entities deleted from the source.

        mark_all(): Marks all entities for deletion.

        run_sync(): Runs rsync to synchronize the source with the destination.

    """

    def __init__(self):
        super(MainWindow, self).__init__()
        self.setupUi(self)

        self.session = None
        self.config = None
        self.listdelButton.setFocus()

        # Redirecting standard output
        self.output_redirector = OutputRedirector(self.consoleOutput)
        sys.stdout = self.output_redirector
        sys.stderr = self.output_redirector

        # ----- TOOLBAR -----

        # Spacer for buttons
        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Set source
        source_action = QAction(QIcon('src/ui/source.svg'), "Add source", self)
        source_action.triggered.connect(
            lambda: set_dir(self, "source"))
        self.toolbar.addAction(source_action)

        # Set destination
        destination_action = QAction(
            QIcon('src/ui/destination.svg'), "Add destination", self)
        destination_action.triggered.connect(
            lambda: set_dir(self, "destination"))
        self.toolbar.addAction(destination_action)

        # Use defaults
        defaults_action = QAction(QIcon('src/ui/defaults.svg'),
                                  "Use defaults", self)
        defaults_action.triggered.connect(self.defaults_action)
        self.toolbar.addAction(defaults_action)

        # <--- left side
        self.toolbar.addWidget(spacer)
        # right side --->

        # Update
        update_action = QAction(
            QIcon('src/ui/update.svg'), "Update", self)
        update_action.triggered.connect(self.update_action)
        self.toolbar.addAction(update_action)

        # Configuration
        config_action = QAction(
            QIcon('src/ui/configure.svg'), "Configuration", self)
        config_action.triggered.connect(self.config_action)
        self.toolbar.addAction(config_action)

        # About
        about_action = QAction(QIcon('src/ui/help-about.svg'), "About", self)
        about_action.triggered.connect(self.about_action)
        self.toolbar.addAction(about_action)

        # Exit
        exit_action = QAction(QIcon('src/ui/window-close.svg'), "Exit", self)
        exit_action.triggered.connect(self.exit_action)
        self.toolbar.addAction(exit_action)

        # -------------------

        self.listdelButton.clicked.connect(self.list_deletions)
        self.syncButton.clicked.connect(self.run_sync)
        self.delallRadio.clicked.connect(self.mark_all)

    # -----------------
    # ----- SLOTS -----
    # -----------------

    # ----- TOOLBAR -----

    @Slot()
    def defaults_action(self):
        """Set the default source, destination and options stored in
        :ref:`Config.config_path <config-class>` and
        :ref:`MainWindow.config <mainwindow-class>` (toolbar action).
        """

        self.sourceEdit.setText(self.config.source)
        self.destEdit.setText(self.config.destination)
        self.session.options = self.config.options
        self.session.log(f"Source: {self.sourceEdit.text()}\n"
                         f"Destination: {self.destEdit.text()}")
        if self.session.options:
            self.optionsEdit.setText(", ".join(self.session.options))
            self.session.log(f"Additional options: "
                             f"{", ".join(self.session.options)}")
        else:
            self.optionsEdit.clear()
        self.syncButton.setEnabled(False)

    @Slot()
    def update_action(self):
        """Update Git repository and Python environment (toolbar action)."""

        self.listdelButton.setEnabled(False)
        self.statusbar.showMessage("Updating...")

        # Updating Git repo
        self.session.log("Updating Git repository...")
        try:
            result = run(["git", "pull"], text=True)
            if result.returncode == 0:
                self.session.log("Git repository update finished.")
            else:
                self.session.log("Warning: something went wrong "
                                 "while updating Git repository!",
                                 result.returncode)
        except (FileNotFoundError, PermissionError, OSError) as e:
            self.session.log("Error while updating Git repository!", e)

        # Updating Python env
        self.session.log("Updating Python environment...")
        try:
            result = run(["pipenv", "update"], text=True)
            if result.returncode == 0:
                self.session.log("Python environment update finished.")
            else:
                self.session.log("Warning: something went wrong "
                                 "while updating Python environment!",
                                 result.returncode)
        except (FileNotFoundError, PermissionError, OSError) as e:
            self.session.log("Error while updating Python environment!", e)

        # Verifying Python packages
        self.session.log("Verifying Python packages...")
        try:
            result = run(["pipenv", "verify"], text=True)
            if result.returncode == 0:
                self.session.log("Python package verification finished.")
            else:
                self.session.log("Warning: something went wrong "
                                 "while verifying Python packages!",
                                 result.returncode)
        except (FileNotFoundError, PermissionError, OSError) as e:
            self.session.log("Error while verifying Python packages!", e)

        self.statusbar.showMessage("Ready.")
        self.listdelButton.setEnabled(True)

    @Slot()
    def config_action(self):
        """Open the 'Configuration' dialog (toolbar action).

        :var ConfigDialog dialog: Configuration dialog
        """

        dialog = ConfigDialog(self.config)
        # `ConfigDialog.config_updated` emits the signal when configs are saved
        dialog.config_updated.connect(self.config_updated)
        dialog.exec()

    @Slot()
    def about_action(self):
        """Open the 'About' dialog (toolbar action).

        :var AboutDialog dialog: About dialog.
        """

        dialog = AboutDialog(self)
        dialog.exec()

    @Slot()
    def exit_action(self):
        """Close the application (toolbar action)."""

        sys.exit("Goodbye!")

    # -------------------

    @Slot()
    def config_updated(self):
        """Reload configurations and validate source and destination.
        The slot is activated when the
        :ref:`ConfigDialog.config_updated <configdialog-class>` signal is
        emitted by the :ref:`ConfigDialog.save <configdialog-save>` method.

        :var Config config: Holds configurations.
        """

        self.config = Config()

        # Validating source
        if not path.exists(self.config.source):
            self.session.log(f"Warning! Invalid source: {self.config.source}")

        # Validating destination
        if not path.exists(self.config.destination):
            self.session.log(f"Warning! Invalid destination: "
                             f"{self.config.destination}")

    @Slot()
    def list_deletions(self):
        """Validate source and destination, then call
        :ref:`Session.get_deletions <get-deletions>` to list
        the deletions to :ref:`MainWindow.consoleOutput <mainwindow-class>`.
        """

        # Setting source and destination from the input boxes
        self.session.source = self.sourceEdit.text()
        self.session.destination = self.destEdit.text()

        # Validating source and destination
        if (path.exists(self.session.source)
                and path.exists(self.session.destination)
                and self.session.source != self.session.destination):

            # Getting list of deletions from the source
            self.statusbar.showMessage("Listing deletions...")
            deletions = self.session.get_deletions()
            if deletions:
                self.session.log(f"{len(deletions)} deletion(s) found, "
                                    f"ready to synchronize.")
                self.delallRadio.setEnabled(True)
                for file in deletions:
                    item = QListWidgetItem(file)
                    item.setFlags(item.flags() |
                                    Qt.ItemFlag.ItemIsUserCheckable)
                    item.setCheckState(Qt.CheckState.Unchecked)
                    self.delList.addItem(item)
            elif isinstance(deletions, CalledProcessError):
                e, c = deletions.stderr, deletions.returncode
                self.session.log(f"Error while listing deletions ({c})!", e)
                self.statusbar.showMessage("Error while listing deletions.")
            else:
                self.session.log("No deletions found, "
                                    "ready to synchronize.")
            self.statusbar.showMessage("Ready to synchronize.")
            self.syncButton.setEnabled(True)
        else:
            if not path.exists(self.session.source):
                self.session.log("Error: Invalid source!")
            if not path.exists(self.session.destination):
                self.session.log("Error: Invalid destination!")
            if self.session.source == self.session.destination:
                self.session.log("Error: Source and destination "
                                 "must be different!")

    @Slot()
    def mark_all(self):
        """Mark all entities listed by
        :ref:`MainWindow.list_deletions <list-deletions-action>` for deletion.
        """

        for index in range(self.delList.count()):
            self.delList.item(index).setCheckState(Qt.CheckState.Checked)

    @Slot()
    def run_sync(self):
        """Call :ref:`Session.sync <sync>` to synchronize
        :ref:`Session.source <session-class>` with
        :ref:`Session.destination <session-class>`.

        :var list entities: Files and directories marked for deletion.
        :var subprocess.CompletedProcess result: The result object
            of the `subprocess.run` method.
        """

        # Concatenating source/destination with entity path for deletions
        entities = [path.join(self.session.destination,
                              self.delList.item(index).text())
                    for index in range(self.delList.count())
                    if self.delList.item(index).checkState()
                    == Qt.CheckState.Checked]

        # Deleting files/directories
        self.session.deleted = 0
        for entity in entities:
            try:
                self.session.delete_entity(entity)
                self.session.deleted += 1
                self.session.log(f"{entity} deleted.")
            except (FileNotFoundError, PermissionError, OSError) as e:
                self.session.log(f"Error while deleting {entity}!", e)
        self.session.log(f"{self.session.deleted} entities deleted.")

        # Setting and validating options
        self.session.options = list(set(
            self.optionsEdit.text().split(", "))) if (
            self.optionsEdit.text().strip()) else None
        self.session.options = validate_options(self.session.options)
        if self.session.options:
            self.optionsEdit.setText(", ".join(self.session.options))

        # Synchronizing source and destination with rsync
        self.session.log(f"Syncing from {self.session.source} "
                         f"to {self.session.destination}"
                         f"{" with additional options: " +
                            ", ".join(self.session.options) + "..."
                         if self.session.options else "..."}")
        self.statusbar.showMessage("Synchronizing...")
        result = self.session.sync()
        if result.returncode == 0:
            self.session.log("Synchronization finished.")
        else:
            self.session.log("Warning: something went wrong "
                                "while running rsync!",
                                result.returncode)

        self.statusbar.showMessage("Ready.")
        self.delList.clear()
        self.delallRadio.setChecked(False)
        self.delallRadio.setEnabled(False)
        self.syncButton.setEnabled(False)


# main function
def main():
    """arXive GUI script.

    The purpose of the script is to run the arXive application in a graphical
    (Qt) environment. Details on usage can be found in the
    `README <https://github.com/gaaldvd/arxive?tab=readme-ov-file#arxive>`_
    of the repository.
    `Technical documentation <https://arxive.readthedocs.io/en/latest/reference.html>`_
    is also available for developers.

    :var MainWindow window: The main window of the GUI.
        All the session related logic is documented in the class description.
    """

    app = QApplication(sys.argv)
    window = MainWindow()

    # Creating session log
    try:
        window.session = Session()
        window.session.log("Session log created.")
    except (FileNotFoundError, PermissionError, OSError) as e:
        print(f"Error while creating session log: {e}")
        window.session = None

    # Loading config file
    try:
        window.config = Config()
        window.session.log("Configurations loaded.")
    except (FileNotFoundError, PermissionError, OSError) as e:
        window.session.log("Error while loading configurations!", e)
        window.statusbar.showMessage("Configurations could not be loaded.")

    # Setting source, destination and options
    if len(sys.argv[1]) > 0 and len(sys.argv[2]) > 0:
        window.session.source = sys.argv[1]
        window.session.destination = sys.argv[2]
    else:
        window.session.source = window.config.source
        window.session.destination = window.config.destination

    window.sourceEdit.setText(window.session.source)
    window.destEdit.setText(window.session.destination)

    window.session.options = window.config.options

    if window.session.source != "":
        window.session.log(f"Source: {window.session.source}")
    if window.session.destination != "":
        window.session.log(f"Destination: {window.session.destination}")
    if window.session.options:
        window.optionsEdit.setText(", ".join(window.session.options))
        window.session.log(f"Additional options: "
                            f"{", ".join(window.session.options)}")

    window.statusbar.showMessage("Ready.")

    # Starting UI
    window.show()
    app.exec()


if __name__ == '__main__':
    main()
